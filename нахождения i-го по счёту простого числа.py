# Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и
# попробуйте его улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.
# Пример работы программ:
# >>> sieve(2)
# 3
# >>> prime(4)
# 7
# >>> sieve(5)
# 11
# >>> prime(1)
# 2
# Использование решета для реализации данной задачи,на мой взгляд является проблемотичным. Поскольку цель решета,
# отобрать простые числа  "в поле чисел". Размер поля заранее известен и является параметром данной (функции).
# То есть,  решето работает для заранее изветсного "поля чисел". В данной задаче, просят найти n -ое, простое число.
# Но дело в том, что заранее мы не знаем, какой размер "поля чисел" потребуется для этого простого числа.
# Задача бы хорошо работала, если бы стояли заранее назначенные ограничения размера искомго порядкогового номера числа.
# Тогда бы могли зарнее знать какой размер поля нам подобрать.
# Я в свою очередь поробую полиативно использовать решето, увеличивая кажды раз поле.


import cProfile
def sieve(n):
    numbers=[]
    i=1
    step=1000

    def create_array(i): # Создаем новое поле для решета
        return [j for j in range ((i-1)*step,i*step)]

    def sieve_old_numbers(): # Применяем решето для нового поля, вычеркивая кратные числа уже имеющиемся простым числам
        min=array[0]
        max=array[-1]
        for num in numbers:
            modulo=min%num
            if modulo==0:
                j=min
            else:
                j=min+num-modulo
            while j<=max:
                array[j-min]=0
                j+=num

    def  sieve_new(): #Класическое решето для первого поля
        array[1]=0
        for j in range(2,step):
            if array[j]!=0:
                k=j*2
                while k<=step-1:
                    array[k]=0
                    k+=j

    def zero_remove():
        return [j for j in array if j!=0 ]


    while len(numbers)<n:
        array=create_array(i)
        if array[0]==0:
            sieve_new()
        else:
            sieve_old_numbers()
        numbers=numbers+zero_remove()
        i+=1

    return numbers[n-1]

# print(sieve(900))
# cProfile.run('sieve(100000)')

# sieve(100) - 0.001
# sieve(1000) - 0.009, увеличение числа в 10 раз время в 10 раз
# sieve(10000) - 0.449, увеличение числа в 100 раз , время в 500 раз (с предыдущим 50 раз)
# sieve(100000) - 45.75 увеличение числа в 1000 раз , время в 45000 раз (с предыдущим 100 раз)

def prime(n):
    numbers=[2,3]
    i=5
    while n>len(numbers):
        for num in numbers:
            if i<num*num:
                numbers.append(i)
                break
            if i%num==0:
                break
        i+=2
    return  numbers[n-1]

# print(prime(100))
cProfile.run('prime(1000000)')
# prime(1000) - 0.01
# prime(10000) - 0.259
# prime(10000 ) - 6.505
# prime(1000000) - 177
